#!/usr/bin/env python3
import socket
import paramiko
import threading
import time
import struct

HOST = "127.0.0.1"
PORT = 5000

SSH_HOST = "127.0.0.1"
SSH_PORT = 2222
SSH_USER = "root"
SSH_PASS = "root"

TERM_WIDTH = 80
TERM_HEIGHT = 24
TERM_TYPE = 'vt100'


def handle_client(client_socket):
    print("[+] TCP client connected")

    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        ssh.connect(SSH_HOST, SSH_PORT, SSH_USER, SSH_PASS, look_for_keys=False)
    except Exception as e:
        print("[bridge] SSH connect error:", e)
        client_socket.close()
        return

    chan = ssh.invoke_shell(term=TERM_TYPE, width=TERM_WIDTH, height=TERM_HEIGHT)
    chan.settimeout(0.1)

    # DISABILITA L’ECHO NEL TERMINALE REMOTO
    chan.send("stty -echo\r")
	
    stop_event = threading.Event()

    # THREAD: SSH -> TCP (forward output to Godot)
    def ssh_to_tcp():
        while not stop_event.is_set():
            try:
                if chan.recv_ready():
                    data = chan.recv(4096)
                    if data:
                        # forward raw bytes to client
                        try:
                            client_socket.sendall(data)
                        except Exception as e:
                            print("[bridge] error sending to tcp:", e)
                            break
                else:
                    time.sleep(0.01)
            except Exception as e:
                if not stop_event.is_set():
                    print("[bridge] ssh->tcp error:", e)
                break

    t = threading.Thread(target=ssh_to_tcp, daemon=True)
    t.start()

    # Buffering for incoming TCP data (Godot) — to handle length-prefixed chunks
    recv_buffer = b""

    try:
        while True:
            try:
                client_socket.settimeout(0.1)
                chunk = client_socket.recv(4096)
            except socket.timeout:
                continue
            except Exception as e:
                print("[bridge] client recv error:", e)
                break

            if not chunk:
                # connection closed by client
                break

            # Debug show raw bytes (helpful)
            print("[bridge] recv from godot (repr):", repr(chunk))

            # Append to buffer and try to extract full messages
            recv_buffer += chunk

            # The protocol coming from Godot here appears to be:
            # [4-byte little-endian length][payload bytes]
            # There may be multiple messages concatenated or fragmented.
            while True:
                if len(recv_buffer) < 4:
                    # not enough bytes to read length
                    break

                # peek 4-byte length (little-endian)
                msg_len = struct.unpack_from("<I", recv_buffer, 0)[0]

                # If msg_len is unrealistic (e.g. huge), fall back to send all as-is:
                if msg_len > 10_000_000:
                    # suspicious length -> send entire buffer raw and clear
                    try:
                        text_all = recv_buffer.decode("utf-8", errors="ignore")
                        chan.send(text_all)
                    except Exception as e:
                        print("[bridge] error sending huge raw:", e)
                    recv_buffer = b""
                    break

                # If we don't yet have the entire message, wait for more bytes
                if len(recv_buffer) < 4 + msg_len:
                    break

                # Extract payload
                payload = recv_buffer[4:4 + msg_len]
                # Remove consumed bytes from buffer
                recv_buffer = recv_buffer[4 + msg_len:]

                # payload is bytes; decode to str for Paramiko channel (keeps control chars)
                try:
                    text = payload.decode("utf-8", errors="ignore")
                except Exception:
                    # fallback: decode latin1 to preserve bytes
                    text = payload.decode("latin-1", errors="ignore")

                # Debug show what we forward
                print("[bridge] forwarding to ssh (repr):", repr(text))

                try:
                    # send to channel (Paramiko will emulate PTY)
                    chan.send(text)
                except Exception as e:
                    print("[bridge] error sending to ssh:", e)
                    stop_event.set()
                    break

            # end while parsing messages

    finally:
        stop_event.set()
        try:
            chan.close()
        except:
            pass
        try:
            ssh.close()
        except:
            pass
        try:
            client_socket.close()
        except:
            pass
        print("[-] client disconnected")


# Main server loop
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
server.bind((HOST, PORT))
server.listen(5)
print("[bridge] listening on", HOST, PORT)

while True:
    client_socket, addr = server.accept()
    print("[bridge] incoming from", addr)
    threading.Thread(target=handle_client, args=(client_socket,), daemon=True).start()



GODOT










extends Control

@onready var editor = $Grid/TopRightEditor
var socket: StreamPeerTCP
var connected := false

var input_buffer := ""     # comandi scritti dall’utente
var last_prompt := ""      # ultimo prompt visto

func _ready():
	socket = StreamPeerTCP.new()
	editor.editable = false
	editor.grab_focus()
	connect_to_bridge()
	set_process(true)

func connect_to_bridge():
	print("[Godot] Connecting…")
	socket.connect_to_host("127.0.0.1", 5000)

func _process(delta):
	socket.poll()

	if not connected and socket.get_status() == StreamPeerTCP.STATUS_CONNECTED:
		connected = true
		print("[Godot] Connected!")
		socket.set_no_delay(true)
		editor.text += ">>> Connected to SSH bridge\n"
		scroll_to_bottom()

	if connected:
		var avail = socket.get_available_bytes()
		if avail > 0:
			var raw = socket.get_utf8_string(avail)
			var cleaned = strip_ansi(raw)

			# estrai l'ultimo prompt
			var rx := RegEx.new()
			rx.compile("([a-zA-Z0-9_]+@[a-zA-Z0-9_\\-]+:.*[#\\$]) *$")
			var m = rx.search(cleaned)
			if m:
				last_prompt = m.get_string(0)

			# mostra output così com'è
			editor.text += "\n"+ cleaned
			scroll_to_bottom()

func _input(event):
	if not connected: return
	if not editor.has_focus(): return
	if not (event is InputEventKey and event.pressed): return

	# =======================
	#       ENTER
	# =======================
	if event.keycode == KEY_ENTER or event.keycode == KEY_KP_ENTER:
		socket.put_utf8_string("\n")
		input_buffer = ""
		# NON bloccare prima, altrimenti TextEdit non va a capo
		await get_tree().process_frame
		scroll_to_bottom()
		get_viewport().set_input_as_handled()
		return


	# =======================
	#      BACKSPACE
	# =======================
	if event.keycode == KEY_BACKSPACE:

		# 1) cancella dal buffer
		if input_buffer.length() > 0:
			input_buffer = input_buffer.substr(0, input_buffer.length() - 1)

			# 2) cancella dal TextEdit localmente
			if editor.text.length() > 0:
				editor.text = editor.text.substr(0, editor.text.length() - 1)

		# 3) invia backspace al terminale reale
		var bs = PackedByteArray([0x7f])
		socket.put_data(bs)

		await get_tree().process_frame
		scroll_to_bottom()
		get_viewport().set_input_as_handled()
		return


	# =======================
	#   CARATTERI NORMALI
	# =======================
	var unicode = event.unicode

	if unicode >= 32 and unicode < 127:
		var ch := char(unicode)

		# 1) aggiorna il buffer
		input_buffer += ch

		# 2) MOSTRA il carattere nell'editor
		editor.text += ch

		# 3) invia al terminale
		socket.put_utf8_string(ch)

		await get_tree().process_frame
		scroll_to_bottom()
		get_viewport().set_input_as_handled()
		return


func scroll_to_bottom():
	editor.scroll_vertical = editor.get_line_count()

func strip_ansi(t:String) -> String:
	var rx = RegEx.new()
	rx.compile("\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])")
	return rx.sub(t, "", true)






ALTRO GODOT






extends Control

@onready var editor = $Grid/TopRightEditor
var socket: StreamPeerTCP
var connected := false

var input_buffer := ""     
var last_prompt := ""      

# ======= CURSORE BLINK =======
var cursor_visible := true
var blink_timer := 0.0
const BLINK_RATE := 0.5

# ======= STORIA COMANDI =======
var cmd_history : Array = []
var history_index := -1
var saved_current := ""

func _ready():
	socket = StreamPeerTCP.new()
	editor.editable = false
	editor.grab_focus()
	connect_to_bridge()
	set_process(true)

func connect_to_bridge():
	print("[Godot] Connecting…")
	socket.connect_to_host("127.0.0.1", 5000)

func _process(delta):
	# ========== CURSORE BLINK ==========
	blink_timer += delta
	if blink_timer >= BLINK_RATE:
		blink_timer = 0
		cursor_visible = !cursor_visible
		update_cursor()

	# ========== TERMINAL OUTPUT ==========
	socket.poll()

	if not connected and socket.get_status() == StreamPeerTCP.STATUS_CONNECTED:
		connected = true
        socket.set_no_delay(true)
		editor.text += ">>> Connected to SSH bridge\n"
		scroll_to_bottom()

	if connected:
		var avail = socket.get_available_bytes()
		if avail > 0:
			var raw = socket.get_utf8_string(avail)
			var cleaned = strip_ansi(raw)

			# prompt detection
			var rx := RegEx.new()
			rx.compile("([a-zA-Z0-9_]+@[a-zA-Z0-9_\\-]+:.*[#\\$]) *$")
			var m = rx.search(cleaned)
			if m:
				last_prompt = m.get_string(0)

			editor.text += "\n" + cleaned
			scroll_to_bottom()
			update_cursor()

# ===========================================
#             CURSORE LAMPEGGIANTE
# ===========================================
func update_cursor():
	# Rimuovi eventuale cursore vecchio
	if editor.text.ends_with("█") or editor.text.ends_with(" "):
		editor.text = editor.text.trim_suffix("█")
		editor.text = editor.text.trim_suffix(" ")

	# Aggiungi nuovo
	if cursor_visible:
		editor.text += "█"
	else:
		editor.text += " "

# ===========================================
#               INPUT
# ===========================================
func _input(event):
	if not connected: return
	if not editor.has_focus(): return
	if not (event is InputEventKey and event.pressed): return

	# ===== Freccia SU = storia precedente =====
	if event.keycode == KEY_UP:
		load_history(-1)
		get_viewport().set_input_as_handled()
		return

	# ===== Freccia GIÙ = storia successiva =====
	if event.keycode == KEY_DOWN:
		load_history(+1)
		get_viewport().set_input_as_handled()
		return

	# =============== ENTER =================
	if event.keycode == KEY_ENTER or event.keycode == KEY_KP_ENTER:
		socket.put_utf8_string("\n")

		# salva nella storia se non vuoto
		if input_buffer.strip_edges() != "":
			cmd_history.append(input_buffer)
		history_index = -1

		input_buffer = ""
		await get_tree().process_frame
		scroll_to_bottom()
		get_viewport().set_input_as_handled()
		return

	# =============== BACKSPACE =================
	if event.keycode == KEY_BACKSPACE:

		if input_buffer.length() > 0:
			input_buffer = input_buffer.substr(0, input_buffer.length() - 1)
			if editor.text.length() > 0:
				editor.text = editor.text.substr(0, editor.text.length() - 2) # -1 char + -1 cursor

		# invia BS al terminale reale
		socket.put_data(PackedByteArray([0x7f]))

		update_cursor()
		await get_tree().process_frame
		scroll_to_bottom()
		get_viewport().set_input_as_handled()
		return

	# =============== CHAR NORMALI =================
	var unicode = event.unicode
	if unicode >= 32 and unicode < 127:
		var ch := char(unicode)

		input_buffer += ch
		editor.text = editor.text.substr(0, editor.text.length() - 1) + ch  # sostituisce cursore

		socket.put_utf8_string(ch)

		update_cursor()
		await get_tree().process_frame
		scroll_to_bottom()
		get_viewport().set_input_as_handled()
		return

# ===========================================
#         STORIA COMANDI (UP/DOWN)
# ===========================================
func load_history(direction: int):
	if cmd_history.is_empty():
		return

	if history_index == -1:
		saved_current = input_buffer

	history_index += direction
	history_index = clamp(history_index, -1, cmd_history.size() - 1)

	if history_index == -1:
		input_buffer = saved_current
	else:
		input_buffer = cmd_history[history_index]

	# aggiorna editor
	editor.text = strip_last_line() + input_buffer
	update_cursor()

func strip_last_line() -> String:
	var lines = editor.text.split("\n")
	if lines.size() > 1:
		lines[lines.size() - 1] = last_prompt
	return "\n".join(lines)

# ===========================================
func scroll_to_bottom():
	editor.scroll_vertical = editor.get_line_count()

func strip_ansi(t:String) -> String:
	var rx = RegEx.new()
	rx.compile("\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])")
	return rx.sub(t, "", true)


	

